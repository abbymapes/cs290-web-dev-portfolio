# Final Project

## Name: 
Abby Mapes - acm103

### Timeline

Start Date: 
- Project Plan: March 20, 2021
- Progress Report 1: April 1, 2021
- Progress Report 2: April 8, 2021
- Final Report: April 9, 2021

Finish Date: 
- Project Plan: March 22, 2021
- Progress Report 1: April 7, 2021
- Progress Report 2: April 14, 2021
- Final Report: 

Hours Spent: 
- Project Plan: ~8 hours
- Progress Report 1: ~20 hours
- Progress Report 2: ~30 hours
- Final Report: ~70 hours

### Collaboration

Resources used:
- Firebase Authentication (https://firebase.google.com/docs/auth)
- Firebase Firestore (https://firebase.google.com/docs/firestore) 

Asset attributions:
- Duke's API Catalog (https://api-catalog.oit.duke.edu/apis/1)
- Bootstrap Vue (https://bootstrap-vue.org/)
- Vue-Horizontal-List (https://github.com/fuxingloh/vue-horizontal-list/tree/master/examples)
- Bootstrap-Vue-Pagination (https://bootstrap-vue.org/docs/components/pagination)
- Bootstrap-Vue-Textarea (https://bootstrap-vue.org/docs/components/form-textarea)
- Bootstrap-Vue-Form-Rating (https://bootstrap-vue.org/docs/components/form-rating)
- Vue2-Waterfall Grid: https://github.com/PLDaily/vue2-waterfall
- Vue-Avatar: https://bootstrap-vue.org/docs/components/avatar

### Assignment Notes

Known Bugs: N/A

Extra credit: I believe that my web application goes above and beyond the requirements for this project and this course. I spent a lot of time handling errors and ensuring that the website runs smoothly and potential bugs are taken care of. 

### Impressions
Ultimately, I'm very proud of what I've accomplished in this project and this course. I feel like I have a solid understanding of the foundations of web development and have been able to create a web app that is responsive, interactive, and useful for Duke students. It was overwhelming having to do this project by myself; however, designing an application from scratch and implementing it very rewarding.

## Set Up Instructions:
Log In Information to Demo Bluebook:
\\
User Account:
- Email: acm103@duke.edu
- Password: password
\\
Admin Account:
- Email: admin@duke.edu
- Password: password

## Data References:
In order to retrieve information about Duke’s course offerings, subjects, and course attributes, I pulled data from the Duke Curriculum API (https://api-catalog.oit.duke.edu/apis/1),  which provides JSON streams of data that contain various course details, including a list of all classes, class synopsis, curriculum details and class sections, and loaded this data into Firebase. The Duke Curriculum API gives members of the Duke community access to the courses offered at Duke. So, all data used for Bluebook is authentic, as it is pulled directly from Duke’s Curriculum API. Note: all other data used for Bluebook is inputted directly by its users. 

## Database Structure:
Below is a description of each of the collections in my database, along with a description of the documents for each collection.

- Courses Collection: The courses collection contains a document for each course returned from Duke’s Curriculum API. A course document contains the following fields: catalogNumber (String), courseCodes (Array), courseId (String), description (String), offerNumber (String), subjectCode (String), subjectName (String), title (String), type (String). Each courseId was the courseId given to courses in Duke’s Catalog API, which the documentation specified were all unique. So, I used the unique courseId as the ID for each course document in Firebase. Here is the JSON data structure that represents each course document: [a relative link](./reports/exampleClassData.json). Note, each property represents a field for a course document. If any of these fields are missing (i.e. a course didn’t have a course code), then they are intialized to an empty version of the data type (i.e. an empty string or array).

- Users Collection: The users collection contains a document for each user and admin account in Bluebook. A user document contains the following fields: userId (String), displayName (String), email (String), picture (String), majors (Array), minors (Array), certificates (Array), subjects (Array), isAdmin (Boolean), visits (Number). Each userId will be generated by Firebase Authentication when the user account is created, so it will be unique. Here is the JSON data structure that represents each user document: [a relative link](./reports/exampleUserData.json). Note, each property represents a field for a user document. If any of these fields are missing (i.e. a user doesn’t have a minor), then they are initialized to an empty version of the data type (i.e. an empty string, array, or the number 0).

- Reactions Collection: The reactions collection contains a document for each time a user reacts to a class in Bluebook (by either liking, disliking, or adding the class to their wishlist). A reaction document contains the following fields: userId (String), courseId (String), reactionId (String), date (Timestamp), dislike (boolean), like (boolean), wishlist (boolean). In order to ensure that users can only have a single reaction for a class (i.e. they can’t like and dislike the same class, wish and dislike the same class, etc), I made the reactionId for each document equal to the concatenation of the userId and the courseId. Therefore, each user can only react once to each course. So, when a user (with userId = abby) clicks the “like” button for a class (with courseId = 123), we can set the “abby123” document in Firebase with the current date, userId, courseId, reactionId, and set like = true, dislike = false, wishlist = false. If any existing documents for “abby123” exist, then user “abby” has already reacted to this class. In this case, Firebase will override this document with the new reaction. Otherwise, if this document doesn’t exist, Firebase will create a new document. Additionally, by the way I’ve validated user inputs, only 1 of “like”, “dislike”, and “wishlist” will be set to true whenever a user reacts to a class (either updating their reaction or making a new reaction). By implementing the reactions this way, we ensure that no user can react twice to a class. However, when the user changes their reaction to a class, I have to remove all existing comments with that reactionId from the comments collection to ensure that the new reaction will start fresh. Here is the JSON data structure that represents a reaction document: [a relative link](./reports/exampleReactionData.json). Note, each property represents a field for a reaction document. For the reactions collection, no reaction documents can be missing any of these fields, which I’ve ensured by design of my web app (explained below).  

- Follows Collection: The follows collection contains a document for each friend relationship between two users in Bluebook. A follows document contains the following fields: followerId (String) and followingId (String), which correspond to the userId of the follower and the userId of the person being followed, respectively. The ID for each follows document will be generated by Firebase. Since I only query by followerId or followingId, I don’t need to store this followId in the document itself. All following data will be generated by users when they follow or unfollow each other. Here is the JSON data structure of a follows document: [a relative link](./reports/exampleFollowsData.json). Note, each property represents a field for a follows document. For these documents, no follows documents can be missing any of these fields, which I’ve ensured by design of my web app (explained below). 

- Comments Collection: The comments collection contains a document for each comment left by a user on a course or a reaction. A comments document contains the following fields: reactionId or courseId (String), userId (String), commentText (String), date (Timestamp). All comments data will be entered by users when they post comments on other people’s reaction posts or on a course page. Each comment document will have a random id generated by Firebase. Note, each comment will either have a reactionId or a courseId, but not both properties. This allows me to query based on reactionId or courseId to retrieve comments for reactions and courses respectively. Here is the JSON data structure for a comment document: [a relative link](./reports/exampleCommentData.json). Note, each property represents a field for a comment document. For these documents, no comment documents can be missing any of these fields (besides one of courseId and reactionId), which I’ve ensured by design of my web app. 

- Subjects Collection: The subjects collection contains a document for each unique subject that the courses from Duke’s Curriculum API were listed under. A subject document contains the following fields: code(String) and name (String). Since subject codes are unique, I made the subject code the id for each subject document in the subjects collection. Here is the JSON data structure of a subject document: [a relative link](./reports/exampleSubjectData.json). Note, each property represents a field for a subject document. For these documents, no subject documents can be missing either of these fields. 

- Attributes Collection: The attributes collection contains a document for each unique attribute that the courses from Duke’s Curriculum API were listed under. An attribute document contains a name (String) field. Since attribute codes are unique, I made the attribute code the id for each attribute document in the attributes collection. Here is the JSON data structure of an attribute document: [a relative link](./reports/exampleAttributeData.json). Note, each property represents a field for an attribute document. For these documents, no attribute documents can be missing either of these fields. 

- Ratings Collection: The ratings collection contains a document for each rating that a user leaves for a course. A ratings document contains the following fields: userId (String), courseId (String), difficulty (Number), interesting (Number). For ratings, similar to reactions, to ensure that a user can only have a single rating for a class (i.e. they can’t rate a class multiple times), I made the id for each rating document equal to the concatenation of the userId and the courseId. So, when a user (with userId = abby) rates a class (with courseId = 123)– either by choosing a difficulty level or a interesting level–, we set the “abby123” rating document with the userId, courseId, current interesting level, and current difficulty level. If any existing rating documents for “abby123” exist, then user “abby” has already rated this class. In this case, Firestore will override this document with the new rating. Otherwise, if this document doesn’t exist, Firestore will create a new document. In doing this, for each course, we are able to pull all rating documents with a courseId equal to that course and do the following: if the interesting property is not 0, we increment the interesting sum and count by 1. Likewise, if the difficulty property is not 0, we increment the difficulty sum and count by 1. Then, we can return the averages of these sums and counts for each course when a user clicks on the course page. This ensures that the ratings displayed for each course are always accurate with the average ratings stored in the database. Here is the JSON data structure of a rating document: [a relative link](./reports/exampleRatingData.json). Note, each property represents a field for a rating document. For these documents, if the difficulty or interesting rating for the course is unrated by the user (i.e. if the user rated the interesting level, but not the difficulty level), then the unrated properties will be set to 0. 

## Types of User Accounts:
For Bluebook, there are 3 different user types.

- Users: Users create an account via the sign up form. To be a user, you must enter a ‘duke.edu’ email address. As a user, you have access to the following pages: Feed, Explore, Profile, User Pages, Subject Pages, Attribute Pages, and Course Pages. Unlike guests and admins, users can add friends by navigating to other people’s pages and adding them as a friend. Additionally, users can add subjects to their profile by navigating to any subject pages and adding them to their profile. Additionally, on course pages, users can react to a course (by liking, disliking, or adding it to their wishlist), rate the course (both interesting and difficulty levels), and comment on the course. When reacting to a course, that course will be added to the user’s profile, under the classes section, and that course reaction will appear in all of their friend’s feed pages. Within a user’s feed page, they can view and comment on all the reactions that their friends have made. Additionally, they can comment on any course reactions within a user’s profile. Users can also edit their profile to change their majors, minors, certificates, profile picture and display name.

- Guests: Guests are any people who view Bluebook without logging in. As a guest, you have access to view the following pages: Explore, User Pages, Subject Pages, Attribute Pages, and Course Pages. Unlike users, guests cannot react to courses, rate courses, comment on courses or other user’s reactions, add subjects to their profile, or add users as friends. However, guests are still able to explore and search for different subject pages, course attribute pages, and user pages, as well as view details about a course on course pages. However, none of these pages will allow guests to edit any data or store any preferences.

- Admin: Admin accounts are made internally (i.e. there is no way for a user to make an admin account in order to protect the admin views). Once logged in as an admin, you have access to the Admin page, which displays all non-admin user accounts in Bluebook and a count of how many times each user has visited the site, as well as the User Pages, Subject Pages, Attribute Pages, and Course Pages. An admin can click on the users within the Admin page and navigate to their profiles, allowing them to view the user’s courses, subjects, and friends. From here, an admin can navigate to course pages, subject pages, user pages and attribute pages (from within the course page). However, like a guest, none of these pages will allow admin accounts to edit any data or store any preferences. If the admin wants to interact with Bluebook as a user, they must log into or create a user account for themselves. This allows the data within Bluebook (i.e. the ratings, comments, etc.) to reflect that of Bluebook’s users. 


## Bad Input Conditions:
In order to validate inputs, data, and error conditions, I’ve implemented the following front-end and server checks. Additionally, whenever the front-end requests data from the backend, if any error occurs, the Vue pages will display a detailed error message in a modal for the users to see.

### Server Validation:
When loading any data and sending it to Bluebook’s front-end Vue pages, I implemented the following checks to ensure that the JSON data sent contains all the necessary fields to create the Vue pages. Here are the following checks for each type of JSON data sent from the server to the front-end. Note: the server does not send any follows JSON data to the front-end, rather it just checks if a document with the appropriate userIds exists in the follows collection and sends ‘doc.id’ to the front-end. As mentioned in Firestore’s documentation, when retrieving a document, if that document exists, it will always have a valid ‘doc.id’ value. So, since we only send ‘doc.id’ to the front-end if a document exists, we do not have to validate the follows data sent to the front end. 

#### Course Data:
- isValidCourseDocument() checks that each course sent to the front-end via JSON data has a non-null courseId, title, catalogNumber, subjectCode, courseCodes, description, and subjectName properties. This ensures that any courses fetched from the frontend by the following endpoints will have the fields necessary to create each page without errors or crashes: ‘/bluebook/getCoursesForSubject’, ‘/bluebook/getCoursesForAttribute’, ‘/bluebook/getDocuments’ (for courses), ‘/bluebook/getFilteredCoursesForSubject’, ‘/bluebook/getFilteredCoursesForAttribute’, ‘/bluebook/getFilteredCourseInformation’. 

#### User Data:
- isValidUserDocument() checks that each user sent to the front-end via JSON data is either an admin account with a non-null userId, displayName, and picture properties OR a non-admin account with a non-null userId, displayName, majors, minors, certificates, subjects, visits, and picture properties. This ensures that any user fetched from the frontend by the following endpoints will have the fields necessary to create each page without errors or crashes: ‘/bluebook/getUserSubjects’, ‘/bluebook/getUser’, ‘/bluebook/getFriends’,  ‘/bluebook/getDocuments’ (for users), ‘/bluebook/getFilteredDocuments’ (for users), ‘/bluebook/getUsersForAdmin’. 

#### Subject Data:
- isValidSubjectDocument() checks that each subject sent to the front-end via JSON data has a non-null name and code properties. This ensures that any subject fetched from the frontend by the following endpoints will have the fields necessary to create each page without errors or crashes: ‘/bluebook/getSubjectNames’, ‘/bluebook/getAllSubjects’, ‘/bluebook/getDocuments’ (for subjects), ‘/bluebook/getFilteredDocuments’ (for subjects)’. 

#### Attribute Data:
- isValidAttributeDocument() checks that each attribute sent to the front-end via JSON data has a non-null name property. This ensures that any attribute fetched from the frontend by the following endpoints will have the fields necessary to create each page without errors or crashes: ‘/bluebook/getDocuments’ (for attributes), ‘/bluebook/getFilteredDocuments’ (for attributes)’. 

#### Comment Data:
- isValidCommentDocument() checks that each comment sent to the front-end via JSON data has a non-null commentText, date, userId and one of (reactionId or courseId) properties. This ensures that any comment fetched from the frontend by the following endpoints will have the fields necessary to create each page without errors or crashes: ‘/bluebook/getReactionComments’, ‘/bluebook/getCourseInformation’ (ensures that all comments for a course are valid’. 

#### Reaction Data: 
- isValidReactionDocument() checks that each reaction sent to the front-end via JSON data has a non-null courseId, date, dislike, like, wishlist, reactionId, and userId properties. This function also ensures that all reactions have only 1 of (like, wishlist, and dislike) set to true. This ensures that any reaction fetched from the frontend by the following endpoints will have the fields necessary to create each page without errors or crashes: ‘/bluebook/getUserInteractions’, ‘/bluebook/getReactions’, ‘/bluebook/getFriendsReactions’. 

#### Rating Data: 
- isValidRatingDocument() checks that each rating sent to the front-end via JSON data has a non-null courseId, difficulty, interesting and userId properties. This ensures that any rating fetched from the frontend by the following endpoints will have the fields necessary to create each page without errors or crashes: ‘/bluebook/getUserInteractions’.


### Front-End Validation:
When sending any data to the server to add to the database, I implemented the following front-end checks to ensure that the JSON data sent to the server contains all the necessary fields to store or update the appropriate documents in Firebase. Here are the following checks for each type of user input sent from the front-end to the server. Note: the only user inputs sent from the front-end to the server are to update the following collections in Firebase: reactions, ratings, comments, follows, and users. So, we validate each of these types of data as mentioned below: 

#### Reaction Data:
- CoursePage.vue: isValidReaction() ensures that the only POST requests made to the server to update a reaction document contain a JSON body with non-null courseId, userId, like, dislike, and wishlist properties. Additionally, this check ensures that only 1 of (like, wishlist, and dislike) set to true for the JSON sent to the server to be stored in the database. This ensures that any JSON data sent to the server (via the endpoint ‘/bluebook/updateUserReaction’) to create or update a document in the ‘reactions’ collection contains the mentioned properties. This ensures that all reaction documents that are created have the fields necessary to create each page without crashes or errors. 

#### Rating Data:
- CoursePage.vue: isValidRating() ensures that the only POST requests made to the server to update a user’s rating for a course contain a JSON body with non-null courseId, userId, interesting, and difficulty properties. Additionally, the form used to input interesting and difficulty ratings only take numeric values between 0 and 5. This ensures that any JSON data sent to the server (via the endpoint ‘/bluebook/updateUserRating’) to create or update a document in the ‘ratings’ collection contains the mentioned properties. This ensures that all rating documents that are created have the fields necessary to create each page without crashes or errors. 

#### Comment Data:
- CoursePage.vue: isValidComment() ensures that the only POST requests made to the server to post a comment for a course contain a JSON body with non-null courseId, userId, commentText, and courseId properties. Additionally, the “submit” button for the input where users type their comments is disabled unless the user types a non-empty comment (with any whitespaces trimmed). This ensures that any JSON data sent to the server (via the endpoint ‘/bluebook/postCourseComment’) to create or update a document in the ‘comments’ collection contains the mentioned properties. This ensures that all comment documents that are created have the fields necessary to create each page without crashes or errors. 
- Reaction.vue: isValidComment() ensures that the only POST requests made to the server to post a comment for a reaction contain a JSON body with non-null courseId, userId, commentText, and reactionId properties. Additionally, the “submit” button for the input where users type their comments is disabled unless the user types a non-empty comment (with any whitespaces trimmed). This ensures that any JSON data sent to the server (via the endpoint ‘/bluebook/postReactionComment’) to create or update a document in the ‘comments’ collection contains the mentioned properties. This ensures that all comment documents that are created have the fields necessary to create each page without crashes or errors. 

#### Follow Data:
- UserPage.vue: isValidFollow() ensures that the only POST requests made to the server to update a following relationship between two users contain a JSON body with non-null followerId and followingId properties. This ensures that any JSON data sent to the server (via the endpoint ‘/bluebook/addFollow’) to create or update a document in the ‘follows’ collection contains the mentioned properties. This ensures that all follows documents that are created have the fields necessary to create each page without crashes or errors. 

#### User Data:
- SignUpPage.vue: On the sign up page, the form where the user fills out their information requires them to input a non-empty name, email, password, and password confirmation. Then, I have implemented the following methods and computed values to check that these fields are valid: nameValidation checks that the user’s display name contains at least 1 non-whitespace character, emailValidation checks that the user’s inputted email address ends with @duke.edu, passwordValidation checks if the user’s inputted password contains at least 8 non-whitespace characters and passwordConfirmationValidation ensures that the user’s confirmation password matches their original one. Once all of these check pass, the user can create an account. When creating the user JSON data to send to the backend, the front-end ensures that: the majors, minors, certificates, and subjects properties are all valid arrays that don’t have any overlapping subjects (either with elements, or empty arrays), the picture property is a string indicating the URL of the user’s profile picture (if they uploaded one) and an empty string otherwise, and that the setAdmin property is set to false. This ensures that any JSON data sent to the server (via the endpoint ‘/bluebook/createUserDocument’) to create a document in the ‘users’ collection contains the mentioned properties. This ensures that all users documents that are created have the fields necessary to create each page without crashes or errors. 

- EditProfile.vue: Likewise, on the Edit Profile component, the form where the user fills out their information requires them to input a non-empty name. Then, I have the method nameValidation checks that the user’s inputted display name contains at least 1 non-whitespace character. Once this check passes, the user can update their account with whatever picture, name, and subject selections they’ve made. When creating the user JSON data to send to the backend, the front-end ensures that: the majors, minors, and certificates are all valid arrays that don’t have any overlapping subjects (either with elements, or empty arrays), the picture property is a string indicating the URL of the user’s new profile picture (if they uploaded a new one), the URL of the user’s old profile picture (if they didn’t upload a new one) and an empty string (if they removed their profile picture). All other properties for the user stay the same, which are validated by the server before they are sent to the front-end. This ensures that any JSON data sent to the server (via the endpoint ‘/bluebook/createUserDocument’) to update a document in the ‘users’ collection contains the mentioned properties. This ensures that all users documents that are created have the fields necessary to create each page without crashes or errors. 



## Framework Decisions:
In order to implement user authentication, I considered using OAuth, with Google, as we’ve discussed in class. Ultimately, the pros for using OAuth with Google were that 1) we’ve gone over OAuth with Google and have received starter code and guidance in class, 2) it allows users to sign on with their existing Google accounts, rather than having to create a new account, and 3) it provides the UI for a login page that I could use instead of creating one. However, one major con with using OAuth with Google was the fact that I only wanted students with an ‘@duke.edu’ email address to create Bluebook user accounts, in order for Bluebook’s data about courses to reflect the opinions of Duke students, rather than random users. So, I began researching other authentication options, including Firebase Authentication. Some of the pros with Firebase Authentication are that 1) it supports authentication using emails and passwords, which would allow me to validate if the email is a ‘@duke.edu’ account before creating the account and 2) it allows me to access current user information within Firebase, which I had already installed and loaded into my project (since I am using Firestore). However, some of the cons with Firebase Authentication were that I had to 1) create a signup and login pages with forms and user inputs, rather than just redirecting the user to a Google page to sign in, and 2) do my own research and problem solving to implement Firebase Authentication, since we hadn’t gone over code to do so in class. Ultimately, I decided to go with Firebase Authentication because it allowed me to attain the goal I had to create a website for Duke students. In the end, due to Google’s helpful documentation, it ended up being the perfect authentication framework for Bluebook. 
\\
\\
I also decided to use ESLint in order to find problems in my code and fix them automatically. I was deciding between using ESLint or the JS validator that we’ve used for past projects in this class. The pros in using ESLint were: 1) it automatically analyzes and fixes my code as I saved my documents, allowing me to minimize the errors made in my code and the time I would spend debugging and validating my code before submitting my project and 2) I could implement it in my Vue files and my node.js files automatically, rather than having to copy and paste these to check them. However, the cons with ESLint were: 1) it inhibited my code from running if there were errors, causing the development process to take more time, and 2) there was a learning curve for me to implement it and get comfortable with the command line tools. On the other hand, the pros with the JS validator were: 1) it allows me to have a faster development process, as I didn’t have to debug little syntax errors everytime I saved a document, and 2) I had used it for the whole semester, so I knew how it worked. However, the cons with the JS validator was that 1) it didn’t automatically detect problems, which could cause me hours debugging retroactively to fix small errors, and 2) I had to copy and paste all my files into the validator, which takes time for a big project like this. Ultimately, I decided to use ESLint and, since I’ve gotten past its learning curve, it has been super helpful in keeping my code clean and error-free.
\\
\\
I also did a lot of research into different open source Vue Components to use for my project. Ultimately, I was looking for components that achieved the following functionalities: a container of objects to display a user’s classes, a grid layout to display classes, pagination for results, a comment section and input section, and class rating inputs. In order to display a user’s classes, I originally was going to use Bootstrap’s Card Group (https://bootstrap-vue.org/docs/components/card), which I used for the Trello assignment. However, after doing research into other open source Vue Components, I eventually found a Vue-Horizontal-List (https://github.com/fuxingloh/vue-horizontal-list/tree/master/examples) that allowed me to display a scrollable horizontal list of Class components. Ultimately, Vue-Horizontal-List was a better choice for this purpose because it allowed me to display the 3 sections of classes (likes, dislikes, and wishlist) in the user profile without having to generate 3 skinny columns of card groups. However, it did take longer to set up and implement than the Vue Card Components we had been using previously in class. I also ended up using this component for the user section, because I liked how it made the user profile page generally compact for these sections. Additionally, in order to display the classes for subjects, attributes, and search results, I wanted a grid component that could display various of my custom Class components. At first, I used Bootstrap’s Card Groups with columns; however, I didn’t like the way that the Card Groups displayed the results vertically in each column, rather than horizontally within the grid (i.e. the first results in the first row, the next ones in the second row, and so on). So, I did some research and ended up finding Vue2-Waterfall Grid (https://github.com/PLDaily/vue2-waterfall), which allowed me to achieve this horizontal loading of objects. At first, I used Vue-Waterfall Grid (rather than this Vue2 version). However, after issues getting that to work, I found that many people used the Vue2 version, which fixed these issues. This led me to find and use the Vue2-Waterfall Grid as the grid throughout the pages of Bluebook. For the rest of the components I used, I tried to find other open source components, such as a “chat section” for the comments section; however, I found that many of these open source components took a lot of time to set up and, even after setting them up, often didn’t work the way that I wanted them to. This led me to use many of Bootstrap Vue’s components and my own custom components and styling to create the features I wanted. Ultimately, while open source components can be great, sometimes it's easier and more productive to create a component yourself that does exactly what you want it to do. This is a big lesson I learned during this project. 